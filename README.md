# firmware for qr-scanner и card-colum

### target:

обеспечить взаимодействие с сервером(java) по управлению и администрированию вьезда/выезда с данными устройствами

---

### описание работы базового функционала:

#### Запрос на осуществление въезда на предприятие - `POST api/qr/receiveQrCode/{deviceId}`

метод который нужно вызывать в момент считывания qr(когда на въезде водитель подносит qr-code к считывающему устройству)
, тем самым запрашивая въезд на территорию предприятия.

**Примечание:** после считывания qr, содержимое qr передается в формате json(в текущей реализации в не зашифрованном
виде) через comport.

**Список параметров:**

```sh
в url надо передать deviceId, пример: /102

{
  "governmentNumber": "string",
  "id": 0,
  "name": "string",
  "surname": "string",
  "uuid": "string"
}
```

**Формат ответа:**

```sh
без ответ, только статус код
```

**Статус:**

1. при успешной отработке - `HttpStatus.OK(200)`
2. при возникновении ошибки(например невалидный qr) - `HttpStatus.Forbidden(403)`
3. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`

#### Запрос на осуществление въезда на предприятие - `POST api/qrScanner/checkQrForEntry`

данный метод генерирует qr на основании данных переданных в json, делает отправку сообщения на указанную почту. Если
отправка завершилась неудачно, то он добавляет письмо очередь и делает повторную отправку(заново отправку осуществлять
не нужно). Также в этом методе есть валидация на гос-номер, почту, планируемую дату въезду.
**Список параметров:**

```sh
{
  "email": "string",
  "enteringDate": "yyyy-MM-dd'T'HH:mm",
  "governmentNumber": "string",
  "name": "string",
  "surname": "string"
}
```

**Формат ответа:**

```sh
50 - возвращается id созданного qr
```

**Статус:**

1. при успешной отработке - `HttpStatus.OK(200)`
2. при возникновении ошибки(например невалидные поля для генерации qr) - `HttpStatus.Forbidden(409)`, нужно для
   отображения на фронте информации
3. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`

#### Осуществление выезда, когда карта вернулась в колонну - `POST api/card/return/{id}`

данный метод вызывается с прошивки когда карточка вернулась в колоннку. На стороне бека проверяется наличие такой
карточки в базе, открытие шлагбаума, удаление записи о метадате карточки из базы данных при успешном открытии шлагбаума.
Если бек ответил ошибкой, то карту необходимо вернуть обратно.

**Список параметров передается в url:**

```sh
/{id}?{deviceId}

id - идентификатор карточки
deviceId - номер устройства с которого пришел запрос
```

**Формат ответа:**

```sh
50 - возвращается id созданного qr
```

**Статус:**

1. при успешной отработке - `HttpStatus.OK(200)`
2. при возникновении ошибки(например не удалось открыть шлагбаум) - `HttpStatus.Forbidden(409)`, нужно для отображения
   на фронте информации, также для оповещения прошивки, что она вернула карту
3. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`